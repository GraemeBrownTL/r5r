---
title: 'Using the time_window parameter'
author: "Rafael H. M. Pereira, Marcus Saraiva, Daniel Herszenhut, Carlos Kaue Braga, Matthew Wigginton Conway"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "This vignette shows how to use and interpret the `time_window` parameter in r5r."
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Using the time_window parameter} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
bibliography: references.json
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1. Introduction 

### The problem
To calculate the travel time from A to B, or to calculate the accessibility level at a given location, one has to select a departure time. However, travel time and accessibility estimates can differ significantly at different departure times because of how public transport service levels vary across the day [@stepniak2019impact]. Even a small difference, say leaving at `10:00am` or `10:04am` might importantly change travel time and accessibility estimates depending on when a person departs relative to when a public transport vehicle arrives, and how well transfers are coordinated given a service timetable. This is a very common issue related to the modifiable temporal unit problem (MTUP) [@pereiramtup2019, @levinson2020manual].

This problem gets even more complicated when public transport GTFS feeds have a `frequencies.txt` table. In these cases, we cannot know the exact departure time of vehicles, what creates greater uncertainty for our travel time and accessibility estimates [@conway2018accounting].


### The solution

A common strategy to overcome this problem is to calculate travel times and accessibilities at multiple departure times sampled over a time window, and then take the average or median value. Now you may ask, but how many departure times should I use? You might also be thinking  that doing multiple repeated routing analysis can be cumbersome and take a lot of time. Right?

Here is where `r5r` comes in. Both the `travel_time_matrix()`and `accessibility()` functions have a parameter called `time_window`. When this parameter is set, R<sup>5</sup> will automatically compute multiple travel times / accessibility estimates starting at the specified `departure_datetime` and within the `time_window` (in minutes) selected by the user.

This vignette shows a reproducible example to explain how one can use the `time_window` and interpret the results.


## 2. How the `time_window` works and how to interpret the results.

As mentioned above, when `time_window` is set, R<sup>5</sup> computes multiple travel times / accessibility estimates starting at the specified `departure_datetime` and within the `time_window` selected by the user.  By default, `r5r` will generate one estimate per minute. Nonetheless, users can set a number to the `draws_per_minute` parameter that will change the number of Monte Carlo draws to perform per time window minute. The default value of `draws_per_minute` is 5, which mean 300 draws in a 60 minutes time window, for example.

In this case, there isn't a single estimate of travel time / accessibility, but a distribution of several estimates that reflect the travel time / accessibility uncertainties in the specified time window. To get our heads around so many estimates, we can use the `percentiles` parameter to specify the percentiles of the distribution we are interested in. For example, if we select the 25th travel time percentile and the results show that the travel time estimate between A and B is 15 minutes, this means that 25% of all trips taken between these points within the specified time window are shorter than 15 minutes.


Let's see a couple concrete examples now.

## 3. Demonstration of `time_window`.

### 3.1 Build routable transport network with `setup_r5()`

First, let's build the network and create the routing inputs. In this example we'll be using the a sample data set for the city of Porto Alegre (Brazil) included in `r5r`.


```{r, message = FALSE, eval = FALSE}
# increase Java memory
options(java.parameters = "-Xmx2G")

# load libraries
library(r5r)
library(sf)
library(data.table)
library(ggplot2)
library(dplyr)

# build a routable transport network with r5r
data_path <- system.file("extdata/poa", package = "r5r")
r5r_core <- setup_r5(data_path, verbose = FALSE)

# routing inputs
mode <- c('walk', 'transit')
max_walk_dist <- 1000 # meters
max_trip_duration <- 90 # minutes

# load origin/destination points
points <- fread(file.path(data_path, "poa_hexgrid.csv"))

```

ps. Please keep in mind that the `time_window` only affects the results when the GTFS feeds contain a `frequencies.txt` table.



### 1.1 Travel time matrix with `time_window`.

Let's calculate all-to-all travel time estimates within a 60-minute time window departing between 2pm and 3pm and see how the output looks like.

```{r, message = FALSE, eval = FALSE}
# estimate travel time matrix

ttm <- travel_time_matrix(r5r_core,   
                          origins = points,
                          destinations = points,    
                          mode = mode,
                          max_walk_dist = max_walk_dist,
                          max_trip_duration = max_trip_duration,
                          departure_datetime = as.POSIXct("13-05-2019 14:00:00", format = "%d-%m-%Y %H:%M:%S"),
                          verbose = FALSE,
                          time_window = 60,
                          percentiles = c(10, 20, 50, 70, 80)
                          )

head(ttm, n = 10)

```
```{r detailed head, echo = FALSE, out.width='100%', message = FALSE}
knitr::include_graphics("https://github.com/ipeaGIT/r5r/blob/master/r-package/inst/img/vig_time_window_ttm_head.png?raw=true")
```



















## 2. Calculate Accessibility

In this example, we will be calculating the number of schools and public healthcare facilities accessible by public transport within a travel time of up to 20 minutes. The sample data provided contains information on the spatial distribution of schools in Porto Alegre in the `points$schools` column, and healthcare facilities in the `points$healthcare` column. 

With the code below we compute the number of schools and healthcare accessible considering median of multiple travel time estimates departing every minute over a 60-minute time window, between 2pm and 3pm. The `accessibility()` function can calculate access to multiple opportunities in a single call, which is much more efficient and convenient than producing a travel time matrix of the study area and manually computing accessibility.


```{r, message = FALSE, eval = FALSE}
# read all points in the city
points <- fread(file.path(data_path, "poa_hexgrid.csv"))

# routing inputs
mode <- c("WALK", "TRANSIT")
max_walk_dist <- 1000 # in meters
travel_time_cutoff <- 21 # in minutes
departure_datetime <- as.POSIXct("13-05-2019 14:00:00",
                                 format = "%d-%m-%Y %H:%M:%S")

time_window <- 60 # in minutes
percentiles <- 50

# calculate travel time matrix
access <- accessibility(r5r_core,
                        origins = points,
                        destinations = points,
                        mode = mode,
                        opportunities_colnames = c("schools", "healthcare"),
                        decay_function = "step",
                        cutoffs = travel_time_cutoff,
                        departure_datetime = departure_datetime,
                        max_walk_dist = max_walk_dist,
                        time_window = time_window,
                        percentiles = percentiles,
                        verbose = FALSE)


head(access)
#>            from_id percentile cutoff accessibility 
#> 1: 89a901291abffff         50     21             3 
#> 2: 89a9012a3cfffff         50     21             0 
#> 3: 89a901295b7ffff         50     21             6 
#> 4: 89a901284a3ffff         50     21             1 
#> 5: 89a9012809bffff         50     21             5 
#> 6: 89a901285cfffff         50     21             3 
```





## 3. Map Accessibility

The final step is mapping the accessibility results calculated earlier. The code
below demonstrates how to do that, with some extra steps to produce a prettier map by doing a spatial interpolation of accessibility estimates.

```{r, message = FALSE, eval = FALSE}
# interpolate estimates to get spatially smooth result
access_schools <- access %>% 
  filter(opportunity == "schools") %>%
  inner_join(points, by='id') %>%
  with(interp(lon, lat, accessibility)) %>%
  with(cbind(acc=as.vector(z),  # Column-major order
             x=rep(x, times=length(y)),
             y=rep(y, each=length(x)))) %>% as.data.frame() %>% na.omit() %>%
  mutate(opportunity = "schools")

access_health <- access %>% 
  filter(opportunity == "healthcare") %>%
  inner_join(points, by='id') %>%
  with(interp(lon, lat, accessibility)) %>%
  with(cbind(acc=as.vector(z),  # Column-major order
             x=rep(x, times=length(y)),
             y=rep(y, each=length(x)))) %>% as.data.frame() %>% na.omit() %>%
  mutate(opportunity = "healthcare")

access.interp <- rbind(access_schools, access_health)

# find results' bounding box to crop the map
bb_x <- c(min(access.interp$x), max(access.interp$x))
bb_y <- c(min(access.interp$y), max(access.interp$y))

# extract OSM network, to plot over map
street_net <- street_network_to_sf(r5r_core)

# plot
ggplot(na.omit(access.interp)) +
  geom_contour_filled(aes(x=x, y=y, z=acc), alpha=.8) +
  geom_sf(data = street_net$edges, color = "gray55", size=0.1, alpha = 0.9) +
  scale_fill_viridis_d(direction = -1, option = 'B') +
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0)) +
  coord_sf(xlim = bb_x, ylim = bb_y, datum = NA) + 
  labs(fill = "Facilities within\n20 minutes\n(median travel time)") +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  facet_wrap(~opportunity)
```

```{r detailed head, echo = FALSE, out.width='100%', message = FALSE}
knitr::include_graphics("https://github.com/ipeaGIT/r5r/blob/master/r-package/inst/img/vig_accessibility.gif?raw=true")
```

If you have any suggestions or want to report an error, please visit [the package GitHub page](https://github.com/ipeaGIT/r5r).

## References
